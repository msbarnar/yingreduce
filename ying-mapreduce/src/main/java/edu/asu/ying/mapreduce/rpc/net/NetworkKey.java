package edu.asu.ying.mapreduce.rpc.net;

import java.io.*;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import edu.asu.ying.mapreduce.table.TableID;

/**
 * {@link NetworkKey} objects associate network routing information with distributable
 * data.
 * <p>
 * The network key is generated by hashing the key elements with an algorithm that
 * provides ideal distribution among the nodes in the network.
 * <p>
 * Key elements should be chosen in such a manner that distributable data can be
 * located on the network given some uniquely identifying information, e.g. a table
 * name.
 * <p>
 * The key is generated lazily.
 */
public final class NetworkKey
	implements Serializable
{
	private static final long serialVersionUID = -8190190245335947345L;
	
	// Digested key
	private byte[] key;
	
	// Used to generate the key from elements
	private transient final MessageDigest digest;
	// True if key is not up to date (needs to be digested)
	private transient boolean needsUpdate = false;
	
	/**
	 * Initializes the hashing algorithm.
	 */
	public NetworkKey() {
		MessageDigest digest;
		try {
			digest = MessageDigest.getInstance("SHA-1");
		} catch (NoSuchAlgorithmException e) {
			digest = null;
		}
		this.digest = digest;
	}
	
	/**
	 * Updates the key in situ and returns the updated NetworkKey.
	 * <p>
	 * The key is hashed lazily, so adding elements does not actually update the key.
	 */
	public final NetworkKey add(final byte[] element) {
		this.digest.update(element);
		this.needsUpdate = true;
		return this;
	}
	/**
	 * Updates the key in situ and returns the updated NetworkKey.
	 * <p>
	 * The key is hashed lazily, so adding elements does not actually update the key.
	 */
	public final NetworkKey add(final int element) {
		return this.add(ByteBuffer.allocate(4).putInt(element).array());
	}
	/**
	 * Updates the key in situ and returns the updated NetworkKey.
	 * Strings are encoded as UTF-8.
	 * <p>
	 * The key is hashed lazily, so adding elements does not actually update the key.
	 */
	public final NetworkKey add(final String element) {
		try {
			return this.add(element.getBytes("UTF-8"));
		} catch (UnsupportedEncodingException e) {
			throw new AssertionError("UTF-8 charset is not available.");
		}
	}
	/**
	 * Updates the key in situ and returns the updated NetworkKey.
	 * <p>
	 * The key is hashed lazily, so adding elements does not actually update the key.
	 */
	public final NetworkKey add(final TableID tableId) {
		return this.add(tableId.toByteArray());
	}
	/**
	 * Copies the hashed value of another {@link NetworkKey} and updates this
	 * key with the result.
	 * <p>
	 * The key is hashed lazily, so adding elements does not actually update the key.
	 */
	public final NetworkKey add(final NetworkKey element) {
		return this.add(element.toByteArray());
	}
	
	public final NetworkKey add(final Serializable element) {
		final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
		ObjectOutputStream stream;
		try {
			stream = new ObjectOutputStream(buffer);
			stream.writeObject(element);
		} catch (final IOException e) {
			throw new IllegalArgumentException("Couldn't serialize key element.", e);
		}
		
		return this.add(buffer.toByteArray());
	}
	
	/**
	 * Lazily hashes the key.
	 */
	private final void digest() {
		this.key = this.digest.digest();
	}
	/**
	 * Lazily hashes the key and returns the result.
	 */
	public final byte[] toByteArray() {
		if (this.needsUpdate) {
			this.digest();
		}
		return this.key;
	}

	/**
	 * Overrides default serialization by lazily hashing the key before
	 * writing the object.
	 */
	private void writeObject(final ObjectOutputStream oos)
				throws IOException {
		if (this.needsUpdate) { 
			this.digest();
		}
		oos.defaultWriteObject();
	}
}
